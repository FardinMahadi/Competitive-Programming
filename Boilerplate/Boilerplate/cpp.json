{
  "C++ Boilerplate with Debugger": {
    "prefix": "boilerplate",
    "body": [
      "// In the name of Allah, the Most Gracious, the Most Merciful",
      "// C: FardinMahadi",
      "",
      "/* ______  __      __  ______  ____",
      "   / ____/ /  \\    / / / |_) ) /    |",
      "  / /___  / /\\ \\  / / / /--<  /_/| |",
      " / ____/ / /  \\ \\/ / / /_)  )   _| |_",
      "/_/     /_/    \\__/ /_/____/   |_____| */",
      "",
      "#include <bits/stdc++.h>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "",
      "using namespace __gnu_pbds;",
      "using namespace std;",
      "",
      "using ll = long long;",
      "using ld = long double;",
      "",
      "template<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "template<typename T> using ordered_multiset = tree<pair<T,int>, null_type, less<pair<T,int>>, rb_tree_tag, tree_order_statistics_node_update>;",
      "// For duplicates: use ordered_multiset<T> and insert {value, unique_id}",
      "// PBDS: find_by_order(k) = iterator to k-th element (0-indexed)",
      "// PBDS: order_of_key(x) = # of elements < x",
      "",
      "#define sp                  ' '",
      "#define nl                  '\\n'",
      "#define F                   first",
      "#define S                   second",
      "#define pb                  push_back",
      "#define pf                  push_front",
      "#define popb                pop_back",
      "#define popf                pop_front",
      "#define gcd(x,y)            __gcd(x,y)",
      "#define no                  cout << \"NO\" << nl",
      "#define yes                 cout << \"YES\" << nl",
      "#define all(a)              (a.begin()),(a.end())",
      "#define SUM(a)              accumulate(all(a),0LL)",
      "#define cinv(v)             for(auto &i : v) cin >> i",
      "#define coutv(v)            for(auto &i : v) cout << i << sp",
      "#define SORT_UNIQUE(c)      (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))",
      "#define UNIQUE(X)           (X).erase(unique(all(X)),(X).end())",
      "#define fixedpoint(x)       cout << fixed << setprecision(x)",
      "#define sz(x)               ((int)(x).size())",
      "#define ceildiv(a,b)        ((a+b-1)/b)",
      "",
      "inline ll lcm(ll a, ll b) {",
      "    if (a == 0 || b == 0) return 0;",
      "    ll g = __gcd(a, b);",
      "#if defined(__SIZEOF_INT128__)",
      "    return (ll)((__int128)a / g * b);",
      "#else",
      "    return a / g * b;",
      "#endif",
      "}",
      "",
      "// Debug (LOCAL)",
      "#ifndef ONLINE_JUDGE",
      "void __print(char x) { cerr << '\\'' << x << '\\''; }",
      "void __print(const char *x) { cerr << '\"' << x << '\"'; }",
      "void __print(const string &x) { cerr << '\"' << x << '\"'; }",
      "void __print(bool x) { cerr << (x ? \"true\" : \"false\"); }",
      "",
      "template<typename T>",
      "typename enable_if<is_arithmetic<T>::value>::type __print(const T &x) { cerr << x; }",
      "",
      "template<typename T>",
      "typename enable_if<!is_arithmetic<T>::value>::type __print(const T &x) {",
      "    int f = 0;",
      "    cerr << '{';",
      "    for (auto it = x.begin(); it != x.end(); ++it) {",
      "        if (f++) cerr << \", \";",
      "        __print(*it);",
      "    }",
      "    cerr << '}';",
      "}",
      "",
      "template<typename A, typename B> void __print(const pair<A, B> &p) { cerr << '('; __print(p.first); cerr << \", \"; __print(p.second); cerr << ')'; }",
      "template<typename T> void __print(const vector<T> &v) { cerr << '['; for (int i = 0; i < (int)v.size(); i++) { if (i) cerr << \", \"; __print(v[i]); } cerr << ']'; }",
      "",
      "void _print() { cerr << \"]\" << nl; }",
      "template <typename T, typename... V>",
      "void _print(T t, V... v) { __print(t); if (sizeof...(v)) cerr << \", \"; _print(v...); }",
      "",
      "#define debug(...) do { cerr << \"[\" << #__VA_ARGS__ << \"] = [\"; _print(__VA_ARGS__); } while(0)",
      "#else",
      "#define debug(...) do {} while(0)",
      "#endif",
      "",
      "// Helpers",
      "template<class T> bool chmin(T &a, const T &b){ if(b < a){ a = b; return true; } return false; }",
      "template<class T> bool chmax(T &a, const T &b){ if(a < b){ a = b; return true; } return false; }",
      "template<class T> vector<T> compress(vector<T> v){ sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); return v; }",
      "",
      "// Constants",
      "constexpr int N = 100000 + 5;",
      "constexpr ll LINF = (1LL<<62);",
      "constexpr int INF = 1000000000;",
      "constexpr int MOD = 1000000007;",
      "const double PI = acos(-1.0);",
      "",
      "void Solve(int tc) {",
      "  $1",
      "}",
      "",
      "int main() {",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(nullptr);",
      "    ",
      "    int t = 1;",
      "    cin >> t;",
      "    for (int tc = 1; tc <= t; tc++) Solve(tc);",
      "    ",
      "    return 0;",
      "}"
    ],
    "description": "Enhanced template with PBDS + safe debug printer (ONLINE_JUDGE aware)"
  },
  "C++ Boilerplate for tutorial": {
    "prefix": "tutBoilerplate",
    "body": [
      "// In the name of Allah, the Most Gracious, the Most Merciful",
      "// C: FardinMahadi",
      "",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "int main() {",
      "    $1",
      "    ",
      "    return 0;",
      "}"
    ],
    "description": "Simple template for tutorials and single test case problems"
  },
  "C++ Binary Search Template": {
    "prefix": "binarySearch",
    "body": [
      "// Binary search on answer",
      "ll binarySearch(ll left, ll right, function<bool(ll)> check) {",
      "    ll ans = right;",
      "    while (left <= right) {",
      "        ll mid = left + (right - left) / 2;",
      "        if (check(mid)) {",
      "            ans = mid;",
      "            right = mid - 1;  // For minimum valid answer",
      "            // left = mid + 1;  // For maximum valid answer",
      "        } else {",
      "            left = mid + 1;  // For minimum valid answer",
      "            // right = mid - 1;  // For maximum valid answer",
      "        }",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "Template for binary search on answer pattern"
  },
  "C++ Binary Exponentiation": {
    "prefix": "binpow",
    "body": [
      "// Binary exponentiation (a^b) mod m",
      "ll binpow(ll a, ll b, ll m = MOD) {",
      "    a %= m;",
      "    ll res = 1;",
      "    while (b > 0) {",
      "        if (b & 1) res = (res * a) % m;",
      "        a = (a * a) % m;",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}"
    ],
    "description": "Fast modular exponentiation using binary exponentiation"
  },
  "C++ Sieve of Eratosthenes": {
    "prefix": "sieve",
    "body": [
      "// Sieve of Eratosthenes - Generate primes up to n",
      "vector<bool> isPrime(N, true);",
      "vector<int> primes;",
      "",
      "void sieve(int n) {",
      "    isPrime[0] = isPrime[1] = false;",
      "    for (int i = 2; i * i <= n; i++) {",
      "        if (isPrime[i]) {",
      "            for (int j = i * i; j <= n; j += i) {",
      "                isPrime[j] = false;",
      "            }",
      "        }",
      "    }",
      "    for (int i = 2; i <= n; i++) {",
      "        if (isPrime[i]) primes.pb(i);",
      "    }",
      "}"
    ],
    "description": "Sieve of Eratosthenes for prime number generation"
  },
  "C++ Extended Euclidean Algorithm": {
    "prefix": "extgcd",
    "body": [
      "// Extended Euclidean Algorithm - returns gcd and coefficients",
      "ll extgcd(ll a, ll b, ll &x, ll &y) {",
      "    if (b == 0) {",
      "        x = 1, y = 0;",
      "        return a;",
      "    }",
      "    ll x1, y1;",
      "    ll g = extgcd(b, a % b, x1, y1);",
      "    x = y1;",
      "    y = x1 - (a / b) * y1;",
      "    return g;",
      "}",
      "",
      "// Modular inverse using extended Euclidean",
      "ll modInverse(ll a, ll m = MOD) {",
      "    ll x, y;",
      "    ll g = extgcd(a, m, x, y);",
      "    if (g != 1) return -1;  // No inverse exists",
      "    return (x % m + m) % m;",
      "}"
    ],
    "description": "Extended Euclidean Algorithm for GCD and modular inverse"
  },
  "C++ Euler Totient Function": {
    "prefix": "phi",
    "body": [
      "// Euler Totient Function using sieve",
      "vector<int> phi(N);",
      "",
      "void eulerTotient(int n) {",
      "    for (int i = 1; i <= n; i++) phi[i] = i;",
      "    for (int i = 2; i <= n; i++) {",
      "        if (phi[i] == i) {  // i is prime",
      "            for (int j = i; j <= n; j += i) {",
      "                phi[j] -= phi[j] / i;",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "Euler Totient Function using sieve method"
  },
  "C++ Modular Arithmetic": {
    "prefix": "modular",
    "body": [
      "// Modular arithmetic operations",
      "ll modAdd(ll a, ll b, ll m = MOD) { return ((a % m) + (b % m)) % m; }",
      "ll modSub(ll a, ll b, ll m = MOD) { return ((a % m) - (b % m) + m) % m; }",
      "ll modMul(ll a, ll b, ll m = MOD) { return ((a % m) * (b % m)) % m; }",
      "ll modDiv(ll a, ll b, ll m = MOD) { return modMul(a, modInverse(b, m), m); }"
    ],
    "description": "Modular arithmetic operations (add, subtract, multiply, divide)"
  },
  "C++ Combinatorics": {
    "prefix": "combinatorics",
    "body": [
      "// Factorial with mod",
      "vector<ll> fact(N);",
      "",
      "void precomputeFactorial(int n, ll m = MOD) {",
      "    fact[0] = 1;",
      "    for (int i = 1; i <= n; i++) {",
      "        fact[i] = (fact[i-1] * i) % m;",
      "    }",
      "}",
      "",
      "// nCr with mod",
      "ll nCr(ll n, ll r, ll m = MOD) {",
      "    if (r > n || r < 0) return 0;",
      "    ll num = fact[n];",
      "    ll den = (fact[r] * fact[n-r]) % m;",
      "    return (num * modInverse(den, m)) % m;",
      "}"
    ],
    "description": "Combinatorics functions: factorial and nCr with modular arithmetic"
  },
  "C++ Prime Factorization": {
    "prefix": "factorize",
    "body": [
      "// Prime factorization",
      "vector<pair<ll, int>> factorize(ll n) {",
      "    vector<pair<ll, int>> factors;",
      "    for (ll i = 2; i * i <= n; i++) {",
      "        if (n % i == 0) {",
      "            int cnt = 0;",
      "            while (n % i == 0) {",
      "                n /= i;",
      "                cnt++;",
      "            }",
      "            factors.pb({i, cnt});",
      "        }",
      "    }",
      "    if (n > 1) factors.pb({n, 1});",
      "    return factors;",
      "}"
    ],
    "description": "Prime factorization of a number"
  },
  "C++ DSU (Disjoint Set Union)": {
    "prefix": "dsu",
    "body": [
      "// DSU with path compression and union by rank",
      "class DSU {",
      "private:",
      "    vector<int> parent, rank;",
      "public:",
      "    DSU(int n) {",
      "        parent.resize(n+1);",
      "        rank.resize(n+1, 0);",
      "        for (int i = 0; i <= n; i++) parent[i] = i;",
      "    }",
      "    ",
      "    int find(int x) {",
      "        if (parent[x] != x) parent[x] = find(parent[x]);",
      "        return parent[x];",
      "    }",
      "    ",
      "    void unite(int x, int y) {",
      "        x = find(x), y = find(y);",
      "        if (x == y) return;",
      "        if (rank[x] < rank[y]) swap(x, y);",
      "        parent[y] = x;",
      "        if (rank[x] == rank[y]) rank[x]++;",
      "    }",
      "    ",
      "    bool same(int x, int y) {",
      "        return find(x) == find(y);",
      "    }",
      "};"
    ],
    "description": "Disjoint Set Union with path compression and union by rank"
  },
  "C++ Segment Tree": {
    "prefix": "segmentTree",
    "body": [
      "// Segment Tree for range queries and updates",
      "class SegmentTree {",
      "private:",
      "    vector<ll> tree;",
      "    int n;",
      "    ",
      "    void build(vector<ll> &arr, int node, int start, int end) {",
      "        if (start == end) {",
      "            tree[node] = arr[start];",
      "        } else {",
      "            int mid = (start + end) / 2;",
      "            build(arr, 2*node, start, mid);",
      "            build(arr, 2*node+1, mid+1, end);",
      "            tree[node] = tree[2*node] + tree[2*node+1];  // Change operation as needed",
      "        }",
      "    }",
      "    ",
      "    void update(int node, int start, int end, int idx, ll val) {",
      "        if (start == end) {",
      "            tree[node] = val;",
      "        } else {",
      "            int mid = (start + end) / 2;",
      "            if (idx <= mid) update(2*node, start, mid, idx, val);",
      "            else update(2*node+1, mid+1, end, idx, val);",
      "            tree[node] = tree[2*node] + tree[2*node+1];",
      "        }",
      "    }",
      "    ",
      "    ll query(int node, int start, int end, int l, int r) {",
      "        if (r < start || l > end) return 0;  // Change identity element as needed",
      "        if (l <= start && end <= r) return tree[node];",
      "        int mid = (start + end) / 2;",
      "        return query(2*node, start, mid, l, r) + query(2*node+1, mid+1, end, l, r);",
      "    }",
      "    ",
      "public:",
      "    SegmentTree(vector<ll> &arr) {",
      "        n = arr.size();",
      "        tree.resize(4*n);",
      "        build(arr, 1, 0, n-1);",
      "    }",
      "    ",
      "    void update(int idx, ll val) {",
      "        update(1, 0, n-1, idx, val);",
      "    }",
      "    ",
      "    ll query(int l, int r) {",
      "        return query(1, 0, n-1, l, r);",
      "    }",
      "};"
    ],
    "description": "Segment Tree for range queries and point updates"
  },
  "C++ Fenwick Tree (BIT)": {
    "prefix": "fenwick",
    "body": [
      "// Fenwick Tree (Binary Indexed Tree)",
      "class FenwickTree {",
      "private:",
      "    vector<ll> tree;",
      "    int n;",
      "    ",
      "public:",
      "    FenwickTree(int size) {",
      "        n = size;",
      "        tree.resize(n+1, 0);",
      "    }",
      "    ",
      "    void update(int idx, ll delta) {",
      "        for (; idx <= n; idx += idx & -idx) {",
      "            tree[idx] += delta;",
      "        }",
      "    }",
      "    ",
      "    ll query(int idx) {",
      "        ll sum = 0;",
      "        for (; idx > 0; idx -= idx & -idx) {",
      "            sum += tree[idx];",
      "        }",
      "        return sum;",
      "    }",
      "    ",
      "    ll rangeQuery(int l, int r) {",
      "        return query(r) - query(l-1);",
      "    }",
      "};"
    ],
    "description": "Fenwick Tree (Binary Indexed Tree) for prefix sum queries"
  },
  "C++ Trie": {
    "prefix": "trie",
    "body": [
      "// Trie (Prefix Tree)",
      "class Trie {",
      "private:",
      "    struct Node {",
      "        vector<Node*> children;",
      "        bool isEnd;",
      "        Node() : children(26, nullptr), isEnd(false) {}",
      "    };",
      "    Node* root;",
      "    ",
      "public:",
      "    Trie() { root = new Node(); }",
      "    ",
      "    void insert(string word) {",
      "        Node* curr = root;",
      "        for (char c : word) {",
      "            int idx = c - 'a';",
      "            if (!curr->children[idx]) {",
      "                curr->children[idx] = new Node();",
      "            }",
      "            curr = curr->children[idx];",
      "        }",
      "        curr->isEnd = true;",
      "    }",
      "    ",
      "    bool search(string word) {",
      "        Node* curr = root;",
      "        for (char c : word) {",
      "            int idx = c - 'a';",
      "            if (!curr->children[idx]) return false;",
      "            curr = curr->children[idx];",
      "        }",
      "        return curr->isEnd;",
      "    }",
      "    ",
      "    bool startsWith(string prefix) {",
      "        Node* curr = root;",
      "        for (char c : prefix) {",
      "            int idx = c - 'a';",
      "            if (!curr->children[idx]) return false;",
      "            curr = curr->children[idx];",
      "        }",
      "        return true;",
      "    }",
      "};"
    ],
    "description": "Trie data structure for string operations"
  },
  "C++ Sparse Table": {
    "prefix": "sparseTable",
    "body": [
      "// Sparse Table for RMQ (Range Minimum Query)",
      "class SparseTable {",
      "private:",
      "    vector<vector<ll>> table;",
      "    vector<int> log;",
      "    ",
      "public:",
      "    SparseTable(vector<ll> &arr) {",
      "        int n = arr.size();",
      "        int maxLog = log2(n) + 1;",
      "        table.assign(n, vector<ll>(maxLog));",
      "        log.resize(n+1);",
      "        ",
      "        for (int i = 0; i < n; i++) table[i][0] = arr[i];",
      "        ",
      "        for (int j = 1; j < maxLog; j++) {",
      "            for (int i = 0; i + (1 << j) <= n; i++) {",
      "                table[i][j] = min(table[i][j-1], table[i + (1 << (j-1))][j-1]);",
      "            }",
      "        }",
      "        ",
      "        for (int i = 2; i <= n; i++) log[i] = log[i/2] + 1;",
      "    }",
      "    ",
      "    ll query(int l, int r) {",
      "        int j = log[r - l + 1];",
      "        return min(table[l][j], table[r - (1 << j) + 1][j]);",
      "    }",
      "};"
    ],
    "description": "Sparse Table for range minimum/maximum queries"
  },
  "C++ Graph Representation": {
    "prefix": "graph",
    "body": [
      "// Graph representation - Adjacency list",
      "vector<vector<int>> adj(N);  // Unweighted",
      "vector<vector<pair<int, int>>> adjWeighted(N);  // Weighted: {node, weight}",
      "",
      "// For directed graph, add edge once",
      "// For undirected graph, add edge twice",
      "void addEdge(int u, int v) {",
      "    adj[u].pb(v);",
      "    // adj[v].pb(u);  // Uncomment for undirected",
      "}",
      "",
      "void addWeightedEdge(int u, int v, int w) {",
      "    adjWeighted[u].pb({v, w});",
      "    // adjWeighted[v].pb({u, w});  // Uncomment for undirected",
      "}"
    ],
    "description": "Graph representation using adjacency lists (weighted and unweighted)"
  },
  "C++ DFS": {
    "prefix": "dfs",
    "body": [
      "// DFS - Depth First Search",
      "vector<bool> visited(N, false);",
      "",
      "void dfs(int u) {",
      "    visited[u] = true;",
      "    for (int v : adj[u]) {",
      "        if (!visited[v]) {",
      "            dfs(v);",
      "        }",
      "    }",
      "}",
      "",
      "// DFS with parent tracking",
      "void dfs(int u, int parent) {",
      "    for (int v : adj[u]) {",
      "        if (v != parent) {",
      "            dfs(v, u);",
      "        }",
      "    }",
      "}"
    ],
    "description": "Depth First Search implementation"
  },
  "C++ BFS": {
    "prefix": "bfs",
    "body": [
      "// BFS - Breadth First Search",
      "vector<bool> visited(N, false);",
      "vector<int> dist(N, -1);",
      "",
      "void bfs(int start) {",
      "    queue<int> q;",
      "    q.push(start);",
      "    visited[start] = true;",
      "    dist[start] = 0;",
      "    ",
      "    while (!q.empty()) {",
      "        int u = q.front();",
      "        q.pop();",
      "        ",
      "        for (int v : adj[u]) {",
      "            if (!visited[v]) {",
      "                visited[v] = true;",
      "                dist[v] = dist[u] + 1;",
      "                q.push(v);",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "Breadth First Search with distance calculation"
  },
  "C++ Dijkstra's Algorithm": {
    "prefix": "dijkstra",
    "body": [
      "// Dijkstra's Algorithm - Single source shortest path",
      "vector<ll> dijkstra(int start, int n) {",
      "    vector<ll> dist(n+1, LINF);",
      "    dist[start] = 0;",
      "    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;",
      "    pq.push({0, start});",
      "    ",
      "    while (!pq.empty()) {",
      "        ll d = pq.top().F;",
      "        int u = pq.top().S;",
      "        pq.pop();",
      "        ",
      "        if (d > dist[u]) continue;",
      "        ",
      "        for (auto [v, w] : adjWeighted[u]) {",
      "            if (dist[u] + w < dist[v]) {",
      "                dist[v] = dist[u] + w;",
      "                pq.push({dist[v], v});",
      "            }",
      "        }",
      "    }",
      "    return dist;",
      "}"
    ],
    "description": "Dijkstra's algorithm for shortest path in weighted graph"
  },
  "C++ Floyd-Warshall": {
    "prefix": "floyd",
    "body": [
      "// Floyd-Warshall - All pairs shortest path",
      "vector<vector<ll>> floydWarshall(int n) {",
      "    vector<vector<ll>> dist(n+1, vector<ll>(n+1, LINF));",
      "    ",
      "    // Initialize distances",
      "    for (int i = 1; i <= n; i++) dist[i][i] = 0;",
      "    for (int u = 1; u <= n; u++) {",
      "        for (auto [v, w] : adjWeighted[u]) {",
      "            dist[u][v] = min(dist[u][v], (ll)w);",
      "        }",
      "    }",
      "    ",
      "    // Floyd-Warshall algorithm",
      "    for (int k = 1; k <= n; k++) {",
      "        for (int i = 1; i <= n; i++) {",
      "            for (int j = 1; j <= n; j++) {",
      "                if (dist[i][k] != LINF && dist[k][j] != LINF) {",
      "                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);",
      "                }",
      "            }",
      "        }",
      "    }",
      "    return dist;",
      "}"
    ],
    "description": "Floyd-Warshall algorithm for all pairs shortest path"
  },
  "C++ Topological Sort": {
    "prefix": "toposort",
    "body": [
      "// Topological Sort using DFS",
      "vector<bool> visited(N, false);",
      "vector<int> topoOrder;",
      "",
      "void dfsTopo(int u) {",
      "    visited[u] = true;",
      "    for (int v : adj[u]) {",
      "        if (!visited[v]) {",
      "            dfsTopo(v);",
      "        }",
      "    }",
      "    topoOrder.pb(u);",
      "}",
      "",
      "vector<int> topologicalSort(int n) {",
      "    topoOrder.clear();",
      "    fill(all(visited), false);",
      "    for (int i = 1; i <= n; i++) {",
      "        if (!visited[i]) dfsTopo(i);",
      "    }",
      "    reverse(all(topoOrder));",
      "    return topoOrder;",
      "}"
    ],
    "description": "Topological sort using DFS"
  },
  "C++ Cycle Detection": {
    "prefix": "cycle",
    "body": [
      "// Cycle detection in directed graph",
      "vector<int> color(N, 0);  // 0: white, 1: gray, 2: black",
      "",
      "bool hasCycle(int u) {",
      "    color[u] = 1;  // Gray",
      "    for (int v : adj[u]) {",
      "        if (color[v] == 1) return true;  // Back edge found",
      "        if (color[v] == 0 && hasCycle(v)) return true;",
      "    }",
      "    color[u] = 2;  // Black",
      "    return false;",
      "}",
      "",
      "// Cycle detection in undirected graph",
      "bool hasCycleUndirected(int u, int parent) {",
      "    visited[u] = true;",
      "    for (int v : adj[u]) {",
      "        if (!visited[v]) {",
      "            if (hasCycleUndirected(v, u)) return true;",
      "        } else if (v != parent) {",
      "            return true;",
      "        }",
      "    }",
      "    return false;",
      "}"
    ],
    "description": "Cycle detection in directed and undirected graphs"
  },
  "C++ Strongly Connected Components (Kosaraju)": {
    "prefix": "scc",
    "body": [
      "// Kosaraju's algorithm for Strongly Connected Components",
      "vector<bool> visited(N, false);",
      "vector<int> order, component;",
      "",
      "void dfs1(int u) {",
      "    visited[u] = true;",
      "    for (int v : adj[u]) {",
      "        if (!visited[v]) dfs1(v);",
      "    }",
      "    order.pb(u);",
      "}",
      "",
      "void dfs2(int u, vector<vector<int>> &adjRev) {",
      "    visited[u] = true;",
      "    component.pb(u);",
      "    for (int v : adjRev[u]) {",
      "        if (!visited[v]) dfs2(v, adjRev);",
      "    }",
      "}",
      "",
      "vector<vector<int>> findSCC(int n) {",
      "    // Build reverse graph",
      "    vector<vector<int>> adjRev(n+1);",
      "    for (int u = 1; u <= n; u++) {",
      "        for (int v : adj[u]) adjRev[v].pb(u);",
      "    }",
      "    ",
      "    // First DFS",
      "    fill(all(visited), false);",
      "    order.clear();",
      "    for (int i = 1; i <= n; i++) {",
      "        if (!visited[i]) dfs1(i);",
      "    }",
      "    ",
      "    // Second DFS on reverse graph",
      "    fill(all(visited), false);",
      "    vector<vector<int>> scc;",
      "    reverse(all(order));",
      "    for (int u : order) {",
      "        if (!visited[u]) {",
      "            component.clear();",
      "            dfs2(u, adjRev);",
      "            scc.pb(component);",
      "        }",
      "    }",
      "    return scc;",
      "}"
    ],
    "description": "Kosaraju's algorithm for finding Strongly Connected Components"
  },
  "C++ KMP Algorithm": {
    "prefix": "kmp",
    "body": [
      "// KMP Algorithm for pattern matching",
      "vector<int> buildLPS(string pattern) {",
      "    int m = pattern.length();",
      "    vector<int> lps(m, 0);",
      "    int len = 0, i = 1;",
      "    ",
      "    while (i < m) {",
      "        if (pattern[i] == pattern[len]) {",
      "            len++;",
      "            lps[i] = len;",
      "            i++;",
      "        } else {",
      "            if (len != 0) len = lps[len-1];",
      "            else { lps[i] = 0; i++; }",
      "        }",
      "    }",
      "    return lps;",
      "}",
      "",
      "vector<int> kmpSearch(string text, string pattern) {",
      "    vector<int> lps = buildLPS(pattern);",
      "    vector<int> matches;",
      "    int n = text.length(), m = pattern.length();",
      "    int i = 0, j = 0;",
      "    ",
      "    while (i < n) {",
      "        if (text[i] == pattern[j]) { i++; j++; }",
      "        if (j == m) {",
      "            matches.pb(i - j);",
      "            j = lps[j-1];",
      "        } else if (i < n && text[i] != pattern[j]) {",
      "            if (j != 0) j = lps[j-1];",
      "            else i++;",
      "        }",
      "    }",
      "    return matches;",
      "}"
    ],
    "description": "KMP algorithm for string pattern matching"
  },
  "C++ Z-Algorithm": {
    "prefix": "zalgorithm",
    "body": [
      "// Z-Algorithm for string preprocessing",
      "vector<int> buildZ(string s) {",
      "    int n = s.length();",
      "    vector<int> z(n, 0);",
      "    int l = 0, r = 0;",
      "    ",
      "    for (int i = 1; i < n; i++) {",
      "        if (i <= r) z[i] = min(r - i + 1, z[i - l]);",
      "        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;",
      "        if (i + z[i] - 1 > r) {",
      "            l = i;",
      "            r = i + z[i] - 1;",
      "        }",
      "    }",
      "    return z;",
      "}",
      "",
      "// Find all occurrences of pattern in text",
      "vector<int> zSearch(string text, string pattern) {",
      "    string combined = pattern + \"$\" + text;",
      "    vector<int> z = buildZ(combined);",
      "    vector<int> matches;",
      "    int m = pattern.length();",
      "    for (int i = m + 1; i < combined.length(); i++) {",
      "        if (z[i] == m) matches.pb(i - m - 1);",
      "    }",
      "    return matches;",
      "}"
    ],
    "description": "Z-Algorithm for string preprocessing and pattern matching"
  },
  "C++ Matrix Exponentiation": {
    "prefix": "matrixExp",
    "body": [
      "// Matrix multiplication",
      "vector<vector<ll>> matMul(vector<vector<ll>> &a, vector<vector<ll>> &b, ll m = MOD) {",
      "    int n = a.size();",
      "    vector<vector<ll>> res(n, vector<ll>(n, 0));",
      "    for (int i = 0; i < n; i++) {",
      "        for (int j = 0; j < n; j++) {",
      "            for (int k = 0; k < n; k++) {",
      "                res[i][j] = (res[i][j] + (a[i][k] * b[k][j]) % m) % m;",
      "            }",
      "        }",
      "    }",
      "    return res;",
      "}",
      "",
      "// Matrix exponentiation",
      "vector<vector<ll>> matPow(vector<vector<ll>> base, ll exp, ll m = MOD) {",
      "    int n = base.size();",
      "    vector<vector<ll>> res(n, vector<ll>(n, 0));",
      "    for (int i = 0; i < n; i++) res[i][i] = 1;  // Identity matrix",
      "    ",
      "    while (exp > 0) {",
      "        if (exp & 1) res = matMul(res, base, m);",
      "        base = matMul(base, base, m);",
      "        exp >>= 1;",
      "    }",
      "    return res;",
      "}"
    ],
    "description": "Matrix multiplication and exponentiation for linear recurrences"
  },
  "C++ Coordinate Compression": {
    "prefix": "compress",
    "body": [
      "// Coordinate compression",
      "vector<int> compress(vector<int> &arr) {",
      "    vector<int> sorted = arr;",
      "    sort(all(sorted));",
      "    sorted.erase(unique(all(sorted)), sorted.end());",
      "    ",
      "    vector<int> compressed;",
      "    for (int x : arr) {",
      "        int idx = lower_bound(all(sorted), x) - sorted.begin();",
      "        compressed.pb(idx);",
      "    }",
      "    return compressed;",
      "}"
    ],
    "description": "Coordinate compression for large coordinate values"
  },
  "C++ String Utilities": {
    "prefix": "stringUtils",
    "body": [
      "// String reverse",
      "string reverseStr(string s) {",
      "    reverse(all(s));",
      "    return s;",
      "}",
      "",
      "// Check if string is palindrome",
      "bool isPalindrome(string s) {",
      "    int n = s.length();",
      "    for (int i = 0; i < n/2; i++) {",
      "        if (s[i] != s[n-1-i]) return false;",
      "    }",
      "    return true;",
      "}",
      "",
      "// Convert string to lowercase",
      "string toLower(string s) {",
      "    transform(all(s), s.begin(), ::tolower);",
      "    return s;",
      "}",
      "",
      "// Convert string to uppercase",
      "string toUpper(string s) {",
      "    transform(all(s), s.begin(), ::toupper);",
      "    return s;",
      "}"
    ],
    "description": "String utility functions: reverse, palindrome check, case conversion"
  },
  "C++ Enhanced Grid Helper": {
    "prefix": "gridHelper",
    "body": [
      "// 4-direction movement",
      "int dx4[] = {-1, 0, +1, 0};",
      "int dy4[] = {0, -1, 0, +1};",
      "",
      "// 8-direction movement (including diagonals)",
      "int dx8[] = {-1, -1, -1, 0, 0, +1, +1, +1};",
      "int dy8[] = {-1, 0, +1, -1, +1, -1, 0, +1};",
      "",
      "// Boundary check",
      "inline bool in(int i, int j) {",
      "    return (0 <= i && i < n && 0 <= j && j < m);",
      "}",
      "",
      "// Grid traversal helper",
      "void traverseGrid(int i, int j) {",
      "    for (int k = 0; k < 4; k++) {  // Change to 8 for diagonal",
      "        int ni = i + dx4[k];",
      "        int nj = j + dy4[k];",
      "        if (in(ni, nj)) {",
      "            // Process cell (ni, nj)",
      "        }",
      "    }",
      "}"
    ],
    "description": "Enhanced grid traversal helper with 4 and 8-direction movement"
  },
  "C++ Merge Sort with Inversion Count": {
    "prefix": "mergeSort",
    "body": [
      "ll inversionCount = 0;",
      "",
      "void merge(vector<int>& arr, int low, int mid, int high) {",
      "    vector<int> temp(high - low + 1);",
      "    int i = low, j = mid + 1, k = 0;",
      "    while (i <= mid && j <= high) {",
      "        if (arr[i] <= arr[j]) temp[k++] = arr[i++];",
      "        else {",
      "            temp[k++] = arr[j++];",
      "            inversionCount += (mid - i + 1);  // Count inversions",
      "        }",
      "    }",
      "    while (i <= mid) temp[k++] = arr[i++];",
      "    while (j <= high) temp[k++] = arr[j++];",
      "    for (int idx = 0; idx < temp.size(); idx++) {",
      "        arr[low + idx] = temp[idx];",
      "    }",
      "}",
      "",
      "void mergeSort(vector<int>& arr, int low, int high) {",
      "    if (low < high) {",
      "        int mid = low + (high - low) / 2;",
      "        mergeSort(arr, low, mid);",
      "        mergeSort(arr, mid + 1, high);",
      "        merge(arr, low, mid, high);",
      "    }",
      "}"
    ],
    "description": "Merge Sort with inversion count"
  },
  "C++ Extended GCD": {
    "prefix": "gcd",
    "body": [
      "// Recursive GCD",
      "ll gcd(ll a, ll b) {",
      "    return b == 0 ? a : gcd(b, a % b);",
      "}",
      "",
      "// Extended GCD (already included in extgcd snippet)",
      "// Use 'extgcd' prefix for extended Euclidean algorithm"
    ],
    "description": "GCD function for two long long numbers"
  },
  "C++ LCM Function": {
    "prefix": "lcm",
    "body": [
      "// Efficient and overflow-safe LCM function",
      "ll lcm(ll a, ll b) {",
      "    return (a / __gcd(a, b)) * b;",
      "}"
    ],
    "description": "Efficient and overflow-safe LCM function for two long long numbers"
  },
  "C++ Split Function": {
    "prefix": "split",
    "body": [
      "// Split string by delimiter",
      "vector<string> split(const string &str, const string &delimiter) {",
      "    vector<string> tokens;",
      "    size_t start = 0, end, delimLength = delimiter.length();",
      "    ",
      "    while ((end = str.find(delimiter, start)) != string::npos) {",
      "        tokens.push_back(str.substr(start, end - start));",
      "        start = end + delimLength;",
      "    }",
      "    tokens.push_back(str.substr(start));",
      "    return tokens;",
      "}"
    ],
    "description": "Function to split a string based on a given delimiter"
  }
}
