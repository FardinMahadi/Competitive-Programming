\section{Templates and Boilerplates}

\subsection{Main C++ Boilerplate}
\begin{lstlisting}
// In the name of Allah, the Most Gracious, the Most Merciful
// C: FardinMahadi

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace __gnu_pbds;
using namespace std;

template<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define sp                  ' '
#define nl                  '\n'
#define F                   first
#define S                   second
#define ll                  long long
#define pb                  push_back
#define pf                  push_front
#define popb                pop_back
#define popf                pop_front
#define gcd(x,y)            __gcd(x,y)
#define lcm(x,y)            y*x/__gcd(x,y)
#define no                  cout << "NO" << nl
#define yes                 cout << "YES" << nl
#define all(a)              (a.begin()),(a.end())
#define SUM(a)              accumulate(all(a),0LL)
#define cinv(v)             for(auto &i : v) cin >> i
#define coutv(v)            for(auto &i : v) cout << i << sp
#define fixedpoint(x)       cout << fixed << setprecision(x)
#define UNIQUE(X)           (X).erase(unique(all(X)),(X).end())
#define print(v)            for(auto x : v) cout << x << " "; cout << nl
#define SORT_UNIQUE(c)      (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))

// Enhanced Macros
#define min3(a,b,c)         min(a,min(b,c))
#define max3(a,b,c)         max(a,max(b,c))
#define min4(a,b,c,d)       min(a,min(b,min(c,d)))
#define max4(a,b,c,d)       max(a,max(b,max(c,d)))
#define sz(x)               ((int)(x).size())
#define sqr(x)              ((x)*(x))
#define ceildiv(a,b)        ((a+b-1)/b)

// Debug Macros
#ifdef LOCAL
#define debug(x)            cerr << #x << " = " << x << nl
#define debug2(x,y)         cerr << #x << " = " << x << ", " << #y << " = " << y << nl
#define debug3(x,y,z)       cerr << #x << " = " << x << ", " << #y << " = " << y << ", " << #z << " = " << z << nl
#define debugv(v)           cerr << #v << " = ["; for(auto x : v) cerr << x << ", "; cerr << "]" << nl
#else
#define debug(x)
#define debug2(x,y)
#define debug3(x,y,z)
#define debugv(v)
#endif

// Constants
const double PI = acos(-1);
const int INF = 1e9 + 7;
const ll LINF = 1e18 + 7;
const int MOD = 1e9 + 7;
const int N = 1e5 + 5;

int n, m;

void Solve(int tc) {
    // Your code here
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    int t = 1;
    cin >> t;
    for (int tc = 1; tc <= t; tc++) Solve(tc);

    return 0;
}
\end{lstlisting}

\subsection{Binary Search Template}
\begin{lstlisting}
// Binary search on answer
ll binarySearch(ll left, ll right, function<bool(ll)> check) {
    ll ans = right;
    while (left <= right) {
        ll mid = left + (right - left) / 2;
        if (check(mid)) {
            ans = mid;
            right = mid - 1;  // For minimum valid answer
            // left = mid + 1;  // For maximum valid answer
        } else {
            left = mid + 1;  // For minimum valid answer
            // right = mid - 1;  // For maximum valid answer
        }
    }
    return ans;
}
\end{lstlisting}

\subsection{Binary Exponentiation}
\begin{lstlisting}
// Binary exponentiation (a^b) mod m
ll binpow(ll a, ll b, ll m = MOD) {
    a %= m;
    ll res = 1;
    while (b > 0) {
        if (b & 1) res = (res * a) % m;
        a = (a * a) % m;
        b >>= 1;
    }
    return res;
}
\end{lstlisting}
